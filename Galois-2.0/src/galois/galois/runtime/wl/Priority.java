/*
Galois, a framework to exploit amorphous data-parallelism in irregular
programs.

Copyright (C) 2010, The University of Texas at Austin. All rights reserved.
UNIVERSITY EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING THIS SOFTWARE
AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR ANY
PARTICULAR PURPOSE, NON-INFRINGEMENT AND WARRANTIES OF PERFORMANCE, AND ANY
WARRANTY THAT MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF TRADE.
NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT TO THE USE OF THE
SOFTWARE OR DOCUMENTATION. Under no circumstances shall University be liable
for incidental, special, indirect, direct or consequential damages or loss of
profits, interruption of business, or related expenses which may arise from use
of Software or Documentation, including but not limited to those resulting from
defects in Software and/or Documentation, or loss or inaccuracy of data of any
kind.


*/





package galois.runtime.wl;

import java.lang.reflect.Constructor;
import java.util.Arrays;

import util.Pair;

/**
 * A class that generates worklists from a series of ordering rules. 
 * 
 *  <p>
 *   Worklists are generated by applying a sequence of <i>ordering rules</i> that
 *   determine how elements in a worklist should be ordered with respect to each
 *   other. A rule <i>R(a, b)</i> is an ordering function over pairs of elements
 *   <i>a, b</i> which specifies whether:
 *   <ol>
 *       <li><i>a</i> should appear before <i>b</i>,
 *       <li><i>b</i> should appear before <i>a</i>, or
 *       <li><i>a</i> and <i>b</i> have no defined order with respect to each
 *           other and can be ordered arbitrarily.
 *   </ol>
 *   
 *   <p>
 *   A sequence of rules <i>R1, R2, R3, ...</i> denotes a lexicographic order in which
 *   elements that are not ordered by <i>R1</i> are ordered by <i>R2</i> and elements
 *   that are not ordered by <i>R2</i> are ordered by <i>R3</i> and so on.
 *
 *   <p>
 *   An example: If our elements have integer priorities and <i>R1</i> orders elements in ascending
 *   priority order and <i>R2</i> orders elements in first-in-first-out (FIFO) order (i.e., queue
 *   order), then <i>R1, R2</i> means the order where elements are processed in increasing
 *   priority order and elements that have the same priority are processed in the same
 *   order they were added to the worklist.
 *   
 *   <p>
 *   Ordering specifications are comprised of two orders: a global order and a local order. The global
 *   order is applied to the initial collection of elements. The local order (if present)
 *   is applied to all the elements generated from processing an element from the global
 *   order. Continuing from the previous example, if <i>R3</i> is last-in-first-out
 *   (LIFO) order (i.e., stack order), then the global order <i>R1, R2</i> and local order
 *   <i>R3</i> means that elements are initially ordered as before, except that any new
 *   elements added while processing element <i>a</i> from the global order are processed
 *   first (in LIFO order) before moving on to the next element in the global order.
 *   
 *   <p>
 *   For unordered Galois iterators, the observed execution may not always match the specified
 *   order. In particular, speculative execution may result in a different observed order
 *   than what was specified. 
 *   
 *   <p>
 *   For ordered Galois iterators, only specifications that only contain {@link Ordered} rules
 *   are valid.
 *   
 *   <p>
 *   Certain rules can only be used as the final rule in a sequence of rules. These rules
 *   are marked with {@link OnlyLeaf}.
 *   
 *   <p>
 *   Concretely, ordering specifications are created by {@link #defaultOrder()}, {@link #first(Class, Object...)},
 *   {@link Priority.Rule#then(Class, Object...)}, and {@link Priority.Rule#thenLocally(Class, Object...)}.
 *   The previous example would be:
 *   <p>
 *   <pre>
 *       Comparator<T> cmp = ... // ascending integer comparator
 *       Priority.first(Ordered.class, cmp).then(FIFO.class).thenLocally(LIFO.class);
 *   </pre>
 *   
 *
 */
public class Priority {
  @SuppressWarnings("unchecked")
  private static <T> Worklist<T> make(boolean isSerial, Rule rule) {
    Pair<Rule, Rule> result = rule.findFirstAndLocal();
    Rule first = result.getFirst();
    Rule local = result.getSecond();

    first.updateRules(isSerial);

    if (local != null) {
      local.updateRules(true);
      Maker<T> outerMaker = first.gen();
      Maker<T> innerMaker = local.gen();

      return new LocalWorklist<T>(outerMaker, innerMaker);
    } else {
      return (Worklist<T>) first.gen().make();
    }
  }

  /**
   * Creates a serial worklist from the ordering specification.
   * 
   * @param <T>   the type of elements of the worklist
   * @param rule  the ordering specification
   * @return      a worklist matching the specification
   */
  public static <T> Worklist<T> makeSerial(Rule rule) {
    return make(true, rule);
  }

  /**
   * Creates a worklist from the ordering specification for an unordered Galois iterator.
   * 
   * @param <T>   the type of elements of the worklist
   * @param rule  the ordering specification
   * @return      a worklist matching the specification
   */
  public static <T> Worklist<T> makeUnordered(Rule rule) {
    return make(false, rule);
  }

  /**
   * Creates a worklist from the ordering specification for an ordered Galois iterator.
   * 
   * @param <T>   the type of elements of the worklist
   * @param rule  the ordering specification
   * @return      a worklist matching the specification
   */
  @SuppressWarnings("unchecked")
  public static <T> OrderableWorklist<T> makeOrdered(Rule rule) {
    Worklist<T> wl = make(false, rule);
    if (wl instanceof OrderableWorklist) {
      return (OrderableWorklist<T>) wl;
    } else {
      throw new Error("Rule does not make ordered worklist, use Ordered rules");
    }
  }

  /**
   * Creates a worklist from the ordering specification for an ordered Galois iterator for use
   * in ParaMeter.
   * 
   * @param <T>   the type of elements of the worklist
   * @param rule  the ordering specification
   * @return      a worklist matching the specification
   */
  public static <T> ParameterOrderedWorklist<T> makeParameterOrdered(Rule rule) {
    OrderableWorklist<T> wl = makeOrdered(rule);
    return new ParameterOrderedWorklist<T>(wl.getComparator());
  }

  /**
   * Creates a worklist for an unordered Galois iterator for use
   * in ParaMeter. There is no need for an ordering specification in this case because
   * the default strategy for ParaMeter with unordered iterators is to randomly
   * select elements to execute.
   * 
   * @param <T>   the type of elements of the worklist
   * @return      a worklist matching the specification
   */
  public static <T> ParameterUnorderedWorklist<T> makeParameterUnordered() {
    return new ParameterUnorderedWorklist<T>();
  }

  /**
   * An ordering specification. An ordering specification consists of two parts:
   * a global order and a local order. An order is a sequence of rules chained
   * together by a sequence of {@link #then(Class, Object...)} methods. The first
   * order in an ordering specification is the global order. The
   * {@link #thenLocally(Class, Object...)} method marks the end of the global order
   * and the beginning of the local order.
   * 
   *
   */
  public static class Rule {
    private static Object[] emptyArgs = new Object[0];
    private Rule prev;
    private Rule next;
    private Class<?> rule;
    private Object[] args;
    private boolean needSize;
    private boolean isLocalRule;

    private Rule() {
      args = emptyArgs;
    }

    /**
     * Appends a rule to the current order. Valid arguments to a rule are the same as the
     * arguments to the constructor of each rule class excluding the <code>maker</code> and
     * <code>needSize</code> arguments, which are used internally by the construction
     * algorithm to generate worklists.
     * 
     * <p>
     * Thus, if rule <i>R1</i> has two constructors
     * <code>R1(Maker&lt;T&gt; maker, int needSize)</code> and
     * <code>R1(int size, Maker&lt;T&gt; maker, int needSize)</code>, then there are only two
     * valid calls to this method with <i>R1</i>: <code>then(R1)</code> and <code>then(R1, int)</code>.
     * 
     * @param rule  the rule to append
     * @param args  the arguments to the rule if any
     * @return      a reference to the updated order
     * @see #thenLocally(Class, Object...)
     * @see Priority#first(Class, Object...)
     */
    @SuppressWarnings("unchecked")
    public Rule then(Class<? extends Worklist> rule, Object... args) {
      this.rule = rule;
      this.args = args;
      next = new Rule();
      next.prev = this;
      return next;
    }

    /**
     * Appends a rule, marks the rule and all subsequent rules as belonging to the local order.
     * 
     * <p>
     * This method follows the same convention regarding arguments to rules as {@link #then(Class, Object...)}.
     * 
     * @param rule  the rule to append
     * @param args  the arguments to the rule if any
     * @return      a reference to the updated order
     * @see #then(Class, Object...)
     */
    @SuppressWarnings("unchecked")
    public Rule thenLocally(Class<? extends Worklist> rule, Object... args) {
      this.isLocalRule = true;
      return then(rule, args);
    }

    private void cutAt() {
      prev.next = new Rule();
      prev = null;
    }

    /**
     * Splits the sequence of rules into its global and local parts
     * 
     * @return  a pair containing the first rule of the global and local order respectively. The
     *          pair component is null if the corresponding order is not present.
     */
    Pair<Rule, Rule> findFirstAndLocal() {
      Rule first;
      for (first = this; first.prev != null; first = first.prev)
        ;

      Rule local;
      for (local = first; local != null; local = local.next) {
        if (local.isLocalRule) {
          // Break linked list into two parts
          local.cutAt();
          break;
        }
      }

      return new Pair<Rule, Rule>(first, local);
    }

    private void updateSerial(boolean isSerial) {
      boolean nextIsSerial = isSerial || rule.isAnnotationPresent(NestedAreSerial.class);

      // If in concurrent setting, use concurrent version of rule
      if (!isSerial)
        rule = rule.getAnnotation(MatchingConcurrentVersion.class).value();

      // Use leaf rule for last *non-default* rule (which is
      // always 2nd to last)
      if (next.rule != null) {
        next.updateSerial(nextIsSerial);
      }
    }

    private void updateLeaf() {
      // Use leaf rule for last *non-default* rule (which is
      // always 2nd to last)
      if (next.rule == null) {
        MatchingLeafVersion leaf = rule.getAnnotation(MatchingLeafVersion.class);
        if (leaf != null)
          rule = leaf.value();
      } else if (rule.isAnnotationPresent(OnlyLeaf.class)) {
        throw new Error("Leaf rule used in non-leaf position: " + rule);
      } else {
        next.updateLeaf();
      }
    }

    private void updateBounded() {
      // Make inner chunked rules use appropriate bounds
      if (prev != null && (prev.rule == ChunkedFIFO.class || prev.rule == ChunkedLIFO.class)) {
        if (rule == FIFO.class || rule == BoundedFIFO.class) {
          rule = BoundedFIFO.class;
          args = prev.args;
        } else if (rule == LIFO.class || rule == BoundedLIFO.class) {
          rule = BoundedLIFO.class;
          args = prev.args;
        }
      }

      if (next.rule != null) {
        next.updateBounded();
      }
    }

    /**
     * Applies rule level optimizations to order
     * 
     * @param isSerial  true if the order is used in a serial context
     */
    void updateRules(boolean isSerial) {
      updateNeedSize(false);
      updateLeaf();
      updateBounded();
      updateSerial(isSerial); // last to simplify cases
    }

    private void updateNeedSize(boolean needSize) {
      this.needSize = needSize;

      if (rule == null)
        return;

      boolean nextNeedSize = rule.isAnnotationPresent(NeedsSize.class);
      if (next != null)
        next.updateNeedSize(nextNeedSize);
    }

    @SuppressWarnings("unchecked")
    <T> Maker<T> gen() {
      if (rule == null)
        return null;

      Maker<?> maker = next != null ? next.gen() : null;
      int numArgs = args.length + 2; // for maker and needSize arguments

      // Find first constructor that has same number of parameters
      // and add hidden parameters as necessary 
      for (final Constructor<?> c : rule.getConstructors()) {
        Class<?>[] params = c.getParameterTypes();

        if (params.length == numArgs) {
          final Object[] actuals = new Object[numArgs];
          System.arraycopy(args, 0, actuals, 0, args.length);

          // Add hidden parameters
          actuals[args.length] = maker;
          actuals[args.length + 1] = needSize;

          return new Maker<T>() {
            @Override
            public Worklist<T> make() {
              try {
                return (Worklist<T>) c.newInstance(actuals);
              } catch (Exception e) {
                throw new Error(e);
              }
            }
          };
        }
      }
      throw new Error("Couldn't find matching constructor for " + rule + " with " + numArgs + " args ");
    }

    @Override
    public String toString() {
      return String.format("%s(%s)", rule != null ? rule.getName() : "null", Arrays.toString(args));
    }
  }

  /**
   * Returns a default order suitable for many unordered iterators
   * that balances locality, synchronization overheads, and load balancing.
   * 
   * @return  a default order
   */
  public static Rule defaultOrder() {
    return new Rule().then(ChunkedFIFO.class);
  }

  /**
   * Initializes a new ordering specification with the given first rule. Additional rules
   * can be appended with {@link Priority.Rule#then(Class, Object...)}.
   * 
   * @param rule  the rule to append
   * @param args  arguments to the rule if any
   * @return      a reference to the updated order
   * @see Priority.Rule#then(Class, Object...)
   */
  @SuppressWarnings("unchecked")
  public static Rule first(Class<? extends Worklist> rule, Object... args) {
    return new Rule().then(rule, args);
  }

  /**
   * Creates an ordering specification that uses exactly the given worklist.
   * 
   * @param <T>       type of elements of the worklist
   * @param worklist  the worklist to use
   * @return          an order that uses the given worklist
   */
  public static <T> Rule withWorklist(final Worklist<T> worklist) {
    return new Rule() {
      @SuppressWarnings("unchecked")
      @Override
      public Rule then(Class<? extends Worklist> rule, Object... arg) {
        throw new UnsupportedOperationException();
      }

      @Override
      Pair<Rule, Rule> findFirstAndLocal() {
        return new Pair<Rule, Rule>(this, null);
      }

      @Override
      void updateRules(boolean isSerial) {
      }

      @SuppressWarnings("unchecked")
      Maker<T> gen() {
        return new Maker<T>() {
          @Override
          public Worklist<T> make() {
            return worklist;
          }
        };
      }
    };
  }
}
