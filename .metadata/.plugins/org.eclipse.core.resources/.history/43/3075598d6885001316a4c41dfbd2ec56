import java.util.*;
import java.awt.Point;
public class GridSpaceManager implements SearchSpaceManager{
	public int width, height;
	public int cluster_width, cluster_height;
	private GridSpaceNode[][] grid;
	
	public final int MININUM_ENTRACE_WIDTH = 6;
	
	HashSet<SearchSpaceNode> entrance_nodes = new HashSet<SearchSpaceNode>();
	HashMap<Integer,Integer> distance_cache = new HashMap<Integer,Integer>();
	
	public GridSpaceManager(ArrayList<Obstacle> obstacle_list, int width, int height) {
		grid = new GridSpaceNode[width][height];
		this.width = width;
		this.height = height;
		this.cluster_height = height;
		this.cluster_width =  width;
		
		
		for(int i = 0; i < width; i++) {
			for(int j = 0; j < height; j++) {
				grid[i][j] = new GridSpaceNode(i,j);
			}
		}
		for(int i = 0; i < obstacle_list.size(); i++) {
			Obstacle o = obstacle_list.get(i);
			for(int x = o.x; x < o.x+ o.width; x++)
				for(int y = o.y; y < o.y + o.height; y++) {
					if(x < width && y < height)
						grid[x][y] = null;
				}
		}
		for(int i = 0; i < width; i ++) {
			for(int j = 0; j < height; j++) {
				if(grid[i][j] == null)
					continue;
				ArrayList<SearchSpaceNode> neighbors = new ArrayList<SearchSpaceNode>();
				if(i!= width -1 && grid[i+1][j] != null) neighbors.add(grid[i+1][j]);
				if(i!=0 && grid[i-1][j] != null) neighbors.add(grid[i-1][j]);
				if(j!=height-1 && grid[i][j+1] != null) neighbors.add(grid[i][j+1]);
				if(j!=0 && grid[i][j-1] != null) neighbors.add(grid[i][j-1]);
				grid[i][j].setNeighbors(neighbors);
			}
		}
		
	}
	
	public GridSpaceManager(ArrayList<Obstacle> obstacle_list, 
			int width, int height, int cluster_width, int cluster_height) {
		this(obstacle_list,width,height);
		this.cluster_width = cluster_width;
		this.cluster_height = cluster_height;
		findEntranceNodes();
		findDistanceCache();
	}
	
	public int getClusterID(SearchSpaceNode node) {
		int x = node.point_list[0].x;
		int y = node.point_list[0].y;
		int cluster_id = x/cluster_width + (clustersPerRow())*(y/cluster_height);
		return cluster_id;
	}
	
	public ArrayList<SearchSpaceNode> getNeighborsForNode(SearchSpaceNode node, boolean cluster) {
		ArrayList<SearchSpaceNode> neighbors = node.getNeighbors();
		if(!cluster)
			return neighbors;
		int node_id = getClusterID(node);
		for(SearchSpaceNode neighbor: neighbors) {
			if(getClusterID(neighbor) != node_id)
				neighbors.remove(neighbor);
		}
		return neighbors;
	}
	
	public GridSpaceNode getNode(int x, int y) {
		//if(grid[x][y] == null)
		//	width++;
		return grid[x][y];
	}
	
	private void findEntranceNodes() {
		entrance_nodes.clear();
		
		int clusters_per_row = clustersPerRow();
		int clusters_per_column = clustersPerColumn();
		for(int i = 0; i<clusters_per_row; i++) {
			for(int j = 0; j < clusters_per_column; j++) {
				
				if(i != 0) {
					int x = i*cluster_width;
					int y = j*cluster_height;
					int limit = j*cluster_height + cluster_height;
					int open_count = 0;
					
					if(grid[x][y] != null && (grid[x][y-1] != null || grid[x-1][y] != null))
						entrance_nodes.add(grid[x][y]);
					y++;
					
					for(;y < limit - 1; y++) {
						if(grid[x][y] != null && grid[x-1][y] != null)
							open_count++;
						else {
							if(open_count < MININUM_ENTRANCE_WIDTH)
								entrance_nodes.add(grid[x][y - MINIMUM_ENTRANCE_WIDTH/2]);
						}
					}
					
					if(grid[x][y] != null && (grid[x][y+1] != null || grid[x-1][y] != null))
						entrance_nodes.add(grid[x][y]);
				}
				
			}
		}
		
	}
	
	private void findDistanceCache() {
		
	}
	
	public void getDistanceForCachedNodes() {
		
	}
	
	public int clustersPerRow() {
		return (int)Math.ceil( width / cluster_width);
	}
	public int clustersPerColumn() {
		return (int)Math.ceil( width / cluster_height);
	}
	
}